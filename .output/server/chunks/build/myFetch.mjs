import { shallowReactive, defineComponent, watch, renderSlot, isVNode, getCurrentWatcher, onWatcherCleanup } from 'vue';
import { j as isElement, k as isBoolean, i as isNumber, l as baseURL } from './server.mjs';
import { m as mutable, S as Session } from './index2.mjs';
import { b as buildProps, f as definePropType, i as iconPropType, n as withInstallFunction } from './icon.mjs';
import { g as useEmptyValuesProps, h as useSizeProp, p as provideGlobalConfig } from './index.mjs';
import { isString, isFunction } from '@vue/shared';

const messageTypes = ["success", "info", "warning", "error"];
const messageDefaults = mutable({
  customClass: "",
  center: false,
  dangerouslyUseHTMLString: false,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: false,
  type: "info",
  plain: false,
  offset: 16,
  zIndex: 0,
  grouping: false,
  repeatNum: 1,
  appendTo: void 0
});
buildProps({
  customClass: {
    type: String,
    default: messageDefaults.customClass
  },
  center: {
    type: Boolean,
    default: messageDefaults.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: messageDefaults.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: messageDefaults.duration
  },
  icon: {
    type: iconPropType,
    default: messageDefaults.icon
  },
  id: {
    type: String,
    default: messageDefaults.id
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: messageDefaults.message
  },
  onClose: {
    type: definePropType(Function),
    default: messageDefaults.onClose
  },
  showClose: {
    type: Boolean,
    default: messageDefaults.showClose
  },
  type: {
    type: String,
    values: messageTypes,
    default: messageDefaults.type
  },
  plain: {
    type: Boolean,
    default: messageDefaults.plain
  },
  offset: {
    type: Number,
    default: messageDefaults.offset
  },
  zIndex: {
    type: Number,
    default: messageDefaults.zIndex
  },
  grouping: {
    type: Boolean,
    default: messageDefaults.grouping
  },
  repeatNum: {
    type: Number,
    default: messageDefaults.repeatNum
  }
});

const instances = shallowReactive([]);

const configProviderProps = buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: useSizeProp,
  button: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  },
  ...useEmptyValuesProps
});

const messageConfig = {};
defineComponent({
  name: "ElConfigProvider",
  props: configProviderProps,
  setup(props, { slots }) {
    watch(() => props.message, (val) => {
      Object.assign(messageConfig, val != null ? val : {});
    }, { immediate: true, deep: true });
    const config = provideGlobalConfig(props);
    return () => renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
  }
});

const normalizeOptions = (params) => {
  const options = !params || isString(params) || isVNode(params) || isFunction(params) ? { message: params } : params;
  const normalized = {
    ...messageDefaults,
    ...options
  };
  if (!normalized.appendTo) {
    normalized.appendTo = (void 0).body;
  } else if (isString(normalized.appendTo)) {
    let appendTo = (void 0).querySelector(normalized.appendTo);
    if (!isElement(appendTo)) {
      appendTo = (void 0).body;
    }
    normalized.appendTo = appendTo;
  }
  if (isBoolean(messageConfig.grouping) && !normalized.grouping) {
    normalized.grouping = messageConfig.grouping;
  }
  if (isNumber(messageConfig.duration) && normalized.duration === 3e3) {
    normalized.duration = messageConfig.duration;
  }
  if (isNumber(messageConfig.offset) && normalized.offset === 16) {
    normalized.offset = messageConfig.offset;
  }
  if (isBoolean(messageConfig.showClose) && !normalized.showClose) {
    normalized.showClose = messageConfig.showClose;
  }
  return normalized;
};
const message = (options = {}, context) => {
  return { close: () => void 0 };
};
messageTypes.forEach((type) => {
  message[type] = (options = {}, appContext) => {
    const normalized = normalizeOptions(options);
    return message({ ...normalized });
  };
});
function closeAll(type) {
  for (const instance of instances) {
    if (!type || type === instance.props.type) {
      instance.handler.close();
    }
  }
}
message.closeAll = closeAll;
message._context = null;

const ElMessage = withInstallFunction(message, "$message");

/* empty css                                                                                                                            */
/* empty css                                                                                                                             */
/* empty css                                                                                                                               */
function myFetch(url, params, options) {
  return new Promise(async (resolve, reject) => {
    const controller = new AbortController();
    if (getCurrentWatcher()) {
      onWatcherCleanup(() => {
        controller.abort();
      });
    }
    const token = Session.getSession("token");
    const reqUrl = url.indexOf("http") > -1 ? url : baseURL + url;
    const res = await fetch(reqUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", Token: token },
      body: JSON.stringify(params),
      ...options,
      signal: controller.signal
    });
    let json;
    try {
      json = await res.json();
    } catch (error) {
      ElMessage.error("请求失败！");
      return reject(error);
    }
    if (json.code === 0) {
      ElMessage.error(json.msg);
      return reject(json.data);
    }
    return resolve([json.data, json]);
  });
}

export { ElMessage as E, myFetch as m };
//# sourceMappingURL=myFetch.mjs.map
